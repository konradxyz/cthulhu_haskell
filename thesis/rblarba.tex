%
% Niniejszy plik stanowi przyk³ad formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet u¿ytych poleceñ mo¿na wykorzystywaæ do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrze¿one.
%
% Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Kar³owicz, 05.05.2006
% dodaj opcjê [licencjacka] dla pracy licencjackiej
\documentclass{pracamgr}

\usepackage{polski}
\usepackage{xcolor}
\usepackage{listings}
\lstset { %
    language=C++,   
       basicstyle=\footnotesize,% basic font setting
}
%Jesli uzywasz kodowania polskich znakow ISO-8859-2 nastepna linia powinna byc 
%odkomentowana
\usepackage[latin2]{inputenc}
%Jesli uzywasz kodowania polskich znakow CP-1250 to ta linia powinna byc 
%odkomentowana
%\usepackage[cp1250]{inputenc}

% Dane magistranta:

\author{Konrad Paziewski}

\nralbumu{306410}

\title{Automatyczne zrównoleglanie programów w jêzykach czysto funkcyjnych}

\tytulang{Automatic parallelisation of pure functional programming languages}

%kierunek: Matematyka, Informatyka, ...
\kierunek{Informatyka}

\opiekun{dra hab. Marcina Benke\\
  Instytut Informatyki\\
  }

% miesi±c i~rok:
\date{Listopad 2015}

%Podaæ dziedzinê wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
11.3 Informatyka\\
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.127. Blabalgorithms\\
  D.127.6. Numerical blabalysis}

% S³owa kluczowe:
\keywords{blabaliza ró¿nicowa, fetory $\sigma$-$\rho$, fooizm,
  blarbarucja, blaba, fetoryka, baleronik}

% Tu jest dobre miejsce na Twoje w³asne makra i~¶rodowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  W pracy przedstawiono jêzyk funckyjny Cthulhu i jego implementacjê
  pozwalaj±c± na automatyczne zrównoleglanie programów.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

Prawo Moore'a od lat siedemdziesi±tych dwudziestego wieku dyktowa³o tempo wzrostu wydajno¶ci
uk³adów scalonych. Wyk³adniczy wzrost ilo¶ci tranzystorów na jednostkê powierzchni przy zachowaniu
sta³ej ceny pozwala³ zak³adaæ, ¿e czêstotliwo¶æ taktowania przeciêtnego procesora bêdzie rosn±æ
dwukrotnie co dwa lata. Niestety, w ostatnich latach tendencja ta zanika. Prawo Moore'a nadal
dzia³a w sferze miniaturyzacji elementów uk³adów scalonych. Jednak¿e, nie przek³ada siê to ju¿
na oczekiwany wzrost wydajno¶ci uk³adu. Czêstotliwo¶æ taktowania procesorów nie ro¶nie ju¿
wyk³adniczo.

Du¿o prostszym sposobem na zwiêkszenie teoretycznej mocy obliczeniowej procesora jest
zwiêkszenie liczby rdzeni. Mo¿liwo¶æ równoleg³ego wykonywania n w±tków obliczeñ
w teorii zwiêksza ilo¶æ operacji wykonywanych w jednostce czasu n-krotnie w stosunku
do uk³adu jednow±tkowego.
Uruchomienie kilku procesów wykorzystuj±cych wiele rdzeni procesora
jest proste. Nowoczesne systemy operacyjne zapewniaj± skuteczn± izolacjê miêdzy poszczególnymi
procesami. Taka architektura pozwala na efektywne równoleg³e wykonywanie niezale¿nych od siebie zadañ.
Niestety wykorzystanie wielu jednostek obliczeniowych procesora do wykonania jednego zadania nie jest zagadnieniem trywialnym.
Wymaga to podzia³u zadania na podzadania, rozdzielenia podzadan pomiêdzy poszczególne rdzenie,
a nastêpnie scalenia wyniku.
Niestety programy wspó³bie¿ne s± trudne do przygotowania, analizy i modyfikacji.
Czêsto kod odpowiedzialny za synchronizacjê i podzia³
pracy miêdzy poszczególne w±tki wykonania jest bardziej skomplikowany
ni¿ sama logika programu. Przyjrzyjmy siê nastêpuj±cym dwóm wersjom tej samej funkcji:

\begin{lstlisting}
template<typename A, typename B, typename F>
void map(F& f, std::vector<A>& input, std::vector<B>& output) {
    output.resize(input.size());
    for ( unsigned i = 0; i < input.size(); ++i ){
        output[i] = f(input[i]);
    }
}

template<typename A, typename B, typename F>
void map_par(F& f, std::vector<A>& input, std::vector<B>& output) {
  output.resize(input.size());
  std::vector<std::thread> threads;
  auto operation = [&input, &output, &f](int i) {
    output[i] = f(input[i]);
  };
  for ( unsigned i = 0; i < input.size(); ++i )
    threads.emplace_back(operation, i);
  for ( unsigned i = 0; i < threads.size(); ++i )
    threads[i].join();
}
\end{lstlisting}

Zauwa¿my, ¿e wiêkszo¶æ kodu drugiej z zademonstrowanych tu procedur odpowiada za zrównoleglenie
pracy. Co wiêcej, na pierwszy rzut oka ciê¿ko oceniæ jakie rzeczywi¶cie zadanie wykonuje ta funkcja.

Tego typu problemy czêsto sprawiaj± ¿e programi¶ci uciekaj± od pisania programów wielow±tkowych.
Jawne wykorzystanie klasycznych mechanizmów wielow±tkowych znacz±co utrudnia analizê algorytmu.

\chapter{Motywacja}
Nie ma ¿adnej uniwersalnej miary u¿yteczno¶ci fragmentu oprogramowania.
Jednak¿e, intuicyjnie u¿yteczny program komputerowy powinien spe³niaæ dwa
podstawowe kryteria. Po pierwsze, powinien byæ poprawny. Poprawno¶æ nale¿y
tu rozumieæ jako zgodno¶æ programu ze specyfikacj±, zarówno je¿eli chodzi o zwracane przez
program wyniki jak i zmiany jakie wprowadza w ¶rodowisku w którym dzia³a. Po drugie, program
powinien byæ wykonywalny w okre¶lonym ¶rodowisku - to znaczy powinien istnieæ mechanizm
pozwalaj±cy uruchomiæ dany program w tym ¶rodowisku i uzyskaæ efekty dzia³ania tego¿ programu
tak ¿eby one mo¿liwe do wykorzystania przez system lub osobê która ten program uruchamia.
W szczególno¶ci zatem, wyniki musz± byæ dostêpne na tyle szybko ¿eby wywo³uj±cy
nadal by³ tymi wynikami zainteresowany. Niezale¿nie od tego z jakim systemem mamy do czynienia,
zawsze istnieje jakies ograniczenie czasowe na wykonanie programu czy te¿ czê¶ci programu.
W zale¿no¶ci od sytuacji ograniczenie to mo¿e mieæ warto¶ci od milisekund (dla systemów
wspomagania jazdy), przez sekundy (serwisów WWW lub przegl±darek internetowych) po tygodnie
(dla bardziej skomplikownych obliczeñ statystycznych, gdzie zwykle ograniczeniem nie jest
ju¿ sam czas dzia³ania obliczenia ale jego pochodna - koszt wynajmowania serwerów), zawsze jednak
istnieje i praktycznie zawsze im szybciej program dzia³a tym jest bardziej przydatny.

Mechanizmy wielow±tkowe daj± szansê na zwiêkszenie wydajno¶ci programów, zwiêkszaj±c
jednak równocze¶nie prawdopodobieñstwo b³êdu - czy te¿ niezgodno¶ci ze specyfikacj±.




Tworzenie u¿ytecznych programów wielow±tkowych jest zagadnieniem trudnym.
to byæ 

Dostêp do wspó³dzielonych przez w±tki zasobów
takich jak struktury danych czy te¿ jakiekolwiek obiekty posiadaj±ce wewnêtrzny stan musi
byæ synchronizowany. Synchronizacja z drugiej strony wprowadza dodatkowy narzut na wykonanie
programu, obni¿aj±c wydajno¶æ. Dobrze dzia³aj±cy algorytm wielow±tkowy powinien bezwzglêdnie
zwracaæ wyniki zgodne z jego specyfikacj±. 


\chapter{Podstawowe pojêcia}\label{r:pojecia}
Nie wiem co tu wpisaæ ale wygl±da jak co¶ ciekawego.
Mo¿e da siê tu co¶ wcisn±æ.
\chapter{Opis jêzyka}
Why not?
\section{System typów}
Zbiór  

Cthulhu jest prostym jêzykiem funkcyjnym o ograniczonej liczbie dostêpnych konstrukcji.
Program sk³ada siê z listy definicji typów i funkcji.

Program w tym jêzyku modeluje funkcjê ze zbioru liczb naturalnych w zbior liczb naturalnych.
  

\chapter{Semantyka}
Proponowany jêzyk programowania jest pe³nowarto¶ciowym jêzykiem funkcyjnym.
Pe³na formalna semantyka na 

\chapter{Implementacja}
Przygotowana przez mnie i opsywana w tym dokumencie realizacja jêzyka Cthulhu
sk³ada siê z dwóch czê¶ci. Pierwsz± z nich jest
napisany w Haskellu generator kodu. Jego zadaniem jest statyczna
analiza programu wej¶ciowego i wygenerowanie równowa¿nego programu w C++. 
Generator kodu sprawdza poprawno¶æ
kodu a tak¿e dba o optymalizacje oraz wybór wyra¿eñ które bêd±
obliczane równolegle. 
Drugim elementem jest przygotowane w C++
¶rodowisko uruchomieniowe. Fragmenty te s± po³±czone przez
pewnego rodzaju zbiór instrukcji przypominaj±cych ideowo
instrukcje asemblerowe.

\section{Asembler cthulhu}
\section{Generator kodu}

Zadaniem generatora kodu jest przygotowanie ci±gu instrukcji
które zostan± pó¼niej wykonane przez ¶rodowisko uruchomieniowe.
Proces przygotwania tych instrukcji sk³ada siê z czterech etapów:
\begin{itemize}
\item analiza leksykalno-sk³adniowa
\item analiza semantyczna
\item przygotowanie listy instrukcji
\item wygenerowanie pliku nag³ówkowego C++ zawieraj±cego instrukcje z poprzedniego kroku
\end{itemize}


\subsection{Analiza leksykalno-sk³adniowa}
Parser jêzyka jest generowany przy pomocy narzêdzia BNFC.
Automatycznie, na podstawie zadanej gramatyki generowane
s± modu³y odpowiedzialne za wszystkie tradycyjne etapy analizy
leksykalno-sk³adniowej - to znaczy lekser i parser. Wygenerowany
zostaje te¿ modu³ opisuj±cy strukturê bêd±c± typem wyniku parsowania.
\subsection{Analiza semantyczna}
Celem analizy semantycznej jest sprawdzenie poprawno¶ci programu
a tak¿e powi±zanie identyfikatorów z ich znaczeniem i typem.
Niestandardowe jest to ¿e nie jest kompilowany ca³y program
a jedynie te funkcje które s± osi±galne - byc mo¿e nie bezpo¶rednio
z funkcji g³ównej programu. Z drugiej strony typy i funkcje parametryzowane
kompilowane s± oddzielnie dla ka¿dej kombinacji parametrów.
\subsection{Przygotowanie listy instrukcji} 
W pierwszej fazie analizy generator
Co wiêcej, generator kodu musi wygenerowaæ
dodatkowe informacjê w celu umo¿
Przygotowana przeze mnie implementacja Cthulhu inicjalizuje
obliczenie równoleg³e tylko dla wyra¿eñ bêd±cych wywo³aniami
funkcji. Co wiêcej, jedyne funkcje które  

\section{¦rodowisko uruchomieniowe}
¦rodowisko uruchomieniowe 


\chapter{Przyk³ady}
Kilka wykresów, o

\chapter{Podsumowanie}

W~pracy przedstawiono pierwsz± efektywn± implementacjê blabalizatora
ró¿nicowego.  Umiejêtno¶æ wykonania blabalizy numerycznej dla danych
,,z ¿ycia'' stanowi dla blabalii fetorycznej podobny prze³om, jak dla
innych dziedzin wiedzy stanowi³o og³oszenie teorii Miko³aja Kopernika
i~Gryzybór G³ombaskiego.  Z~pewno¶ci± w~rozpocznynaj±cym siê XXI wieku
bêdziemy obserwowaæ rozkwit blabalii fetorycznej.

Trudno przewidzieæ wszystkie nowe mo¿liwo¶ci, ale te co bardziej
oczywiste mo¿na wskazaæ ju¿ teraz.  S± to:
\begin{itemize}
\item degryzmolizacja wieñców telecentrycznych,
\item realizacja zimnej reakcji lambliarnej,
\item loty celulityczne,
\item dok³adne obliczenie wieku Wszech¶wiata.
\end{itemize}


\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
    function}, Mathematica Absurdica, 117 (1965) 338--9.

\bibitem[Blar16]{eb1} Elizjusz Blarbarucki, \textit{O pewnych
    aspektach pewnych aspektów}, Astrolog Polski, Zeszyt 16, Warszawa
  1916.

\bibitem[Fif00]{ffgg} Filigran Fifak, Gizbert Gryzogrzechotalski,
  \textit{O blabalii fetorycznej}, Materia³y Konferencji Euroblabal
  2000.

\bibitem[Fif01]{ff-sr} Filigran Fifak, \textit{O fetorach
    $\sigma$-$\rho$}, Acta Fetorica, 2001.

\bibitem[G³omb04]{grglo} Gryzybór G³ombaski, \textit{Parazytonikacja
    blabiczna fetorów --- nowa teoria wszystkiego}, Warszawa 1904.

\bibitem[Hopp96]{hopp} Claude Hopper, \textit{On some $\Pi$-hedral
    surfaces in quasi-quasi space}, Omnius University Press, 1996.

\bibitem[Leuk00]{leuk} Lechoslav Leukocyt, \textit{Oval mappings ab ovo},
  Materia³y Bia³ostockiej Konferencji Hodowców Drobiu, 2000.

\bibitem[Rozk93]{JR} Josip A.~Rozkosza, \textit{O pewnych w³asno¶ciach
    pewnych funkcji}, Pó³nocnopomorski Dziennik Matematyczny 63491
  (1993).

\bibitem[Spy59]{spyrpt} Mrowclaw Spyrpt, \textit{A matrix is a matrix
    is a matrix}, Mat. Zburp., 91 (1959) 28--35.

\bibitem[Sri64]{srinis} Rajagopalachari Sriniswamiramanathan,
  \textit{Some expansions on the Flausgloten Theorem on locally
    congested lutches}, J. Math.  Soc., North Bombay, 13 (1964) 72--6.

\bibitem[Whi25]{russell} Alfred N. Whitehead, Bertrand Russell,
  \textit{Principia Mathematica}, Cambridge University Press, 1925.

\bibitem[Zen69]{heu} Zenon Zenon, \textit{U¿yteczne heurystyki
    w~blabalizie}, M³ody Technik, nr~11, 1969.

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
